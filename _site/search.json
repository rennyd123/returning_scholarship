[
  {
    "objectID": "code/cleaning.html",
    "href": "code/cleaning.html",
    "title": "Temperature Data Subset",
    "section": "",
    "text": "import pandas as pd \nimport seaborn as sns \n\nhistoric_data = pd.read_csv(\"../data/NABR_historic.csv\")\n\nhistoric_data.columns\n\ndata_colmap = {\n    \"long\" : \"longitude\",\n    \"lat\" : \"latitude\",\n    \"TimePeriod\" : \"time_period\",\n    \"RCP\" : \"rep_con_path\",\n    \"treecanopy\" : \"pct_treecanopy\", \n    \"Ann_Herb\" : \"pct_annual_herbcov\",\n    \"Bare\" : \"pct_bareground\",\n    \"Herb\" : \"pct_herbcov\",\n    \"Litter\" : \"pct_plantlittercov\",\n    \"Shrub\" : \"pct_shrubcov\",\n    \"DrySoilDays_Summer_whole\" : \"drysoildays_summer\",\n    \"Evap_Summer\" : \"evap_summer\", \n    \"ExtremeShortTermDryStress_Summer_whole\" : \"xtr_st_drysoilstress_summer\", \n    \"FrostDays_Winter\" : \"frostdays_winter\", \n    \"NonDrySWA_Summer_whole\" : \"nondry_swa_summer\",\n    \"PPT_Winter\" : \"precipitation_winter\", \n    \"PPT_Summer\" : \"precipitation_summer\",\n    \"PPT_Annual\" : \"precipitation_annual\", \n    \"T_Winter\" : \"temp_winter\",\n    \"T_Summer\" : \"temp_summer\", \n    \"T_Annual\" : \"temp_annual\", \n    \"Tmax_Summer\" : \"maxtemp_summer\", \n    \"Tmin_Winter\" : \"mintemp_winter\", \n    \"VWC_Winter_whole\" : \"volwater_winter\", \n    \"VWC_Spring_whole\" : \"volwater_spring\", \n    \"VWC_Summer_whole\" : \"volwater_summer\", \n    \"VWC_Fall_whole\" : \"volwater_fall\"\n}\n\nhistoric_data = historic_data.rename(columns=data_colmap)\n\n\ntemp_subset_cols = [\"longitude\", \"latitude\", \"year\", \"frostdays_winter\", 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']\ntemp_subset_hist = historic_data[temp_subset_cols]\n\ntemp_data_agg = temp_subset_hist.groupby(\"year\")[['temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']].agg(\"mean\").reset_index()\n\nrecent_data = pd.read_csv(\"../data/nearterm_data_2020-2024.csv\")\nrecent_data = recent_data.rename(columns=data_colmap)\n\ntemp_subset_cols = [\"year\", \"frostdays_winter\", 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']\ntemp_subset_recent = recent_data[temp_subset_cols]\n\ncleaned_recent_subset = temp_subset_recent.groupby(\"year\")[['temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']].agg(\"mean\").reset_index()\n\ncleaned_temp_subset = pd.merge(temp_data_agg, cleaned_recent_subset, on = ['year', 'temp_winter', 'temp_summer', 'temp_annual',\n       'maxtemp_summer', 'mintemp_winter'], how = \"outer\")\ncleaned_temp_subset.to_csv(\"../data/cleaned_temp_subset.csv\")"
  },
  {
    "objectID": "website/tabs/coverage/coverage.html",
    "href": "website/tabs/coverage/coverage.html",
    "title": "Returning Student Scholarship Application",
    "section": "",
    "text": "1+1"
  },
  {
    "objectID": "website/tabs/temperature/temperature.html",
    "href": "website/tabs/temperature/temperature.html",
    "title": "Current Data",
    "section": "",
    "text": "import pandas as pd \nimport seaborn as sns \n\nhistoric_data = pd.read_csv(\"../../../data/NABR_historic.csv\")\n\nhistoric_data.columns\n\ndata_colmap = {\n    \"long\" : \"longitude\",\n    \"lat\" : \"latitude\",\n    \"TimePeriod\" : \"time_period\",\n    \"RCP\" : \"rep_con_path\",\n    \"treecanopy\" : \"pct_treecanopy\", \n    \"Ann_Herb\" : \"pct_annual_herbcov\",\n    \"Bare\" : \"pct_bareground\",\n    \"Herb\" : \"pct_herbcov\",\n    \"Litter\" : \"pct_plantlittercov\",\n    \"Shrub\" : \"pct_shrubcov\",\n    \"DrySoilDays_Summer_whole\" : \"drysoildays_summer\",\n    \"Evap_Summer\" : \"evap_summer\", \n    \"ExtremeShortTermDryStress_Summer_whole\" : \"xtr_st_drysoilstress_summer\", \n    \"FrostDays_Winter\" : \"frostdays_winter\", \n    \"NonDrySWA_Summer_whole\" : \"nondry_swa_summer\",\n    \"PPT_Winter\" : \"precipitation_winter\", \n    \"PPT_Summer\" : \"precipitation_summer\",\n    \"PPT_Annual\" : \"precipitation_annual\", \n    \"T_Winter\" : \"temp_winter\",\n    \"T_Summer\" : \"temp_summer\", \n    \"T_Annual\" : \"temp_annual\", \n    \"Tmax_Summer\" : \"maxtemp_summer\", \n    \"Tmin_Winter\" : \"mintemp_winter\", \n    \"VWC_Winter_whole\" : \"volwater_winter\", \n    \"VWC_Spring_whole\" : \"volwater_spring\", \n    \"VWC_Summer_whole\" : \"volwater_summer\", \n    \"VWC_Fall_whole\" : \"volwater_fall\"\n}\n\nhistoric_data = historic_data.rename(columns=data_colmap)\nhistoric_data.columns\n\n\nimport plotly.express as px\nimport plotly \n\ntemp_subset_cols = [\"longitude\", \"latitude\", \"year\", \"frostdays_winter\", 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']\ntemp_subset_hist = historic_data[temp_subset_cols]\ntemp_subset_hist.head(10)\n\n\nfdw = [\"year\", \"frostdays_winter\", \"longitude\", \"latitude\"]\nfdw = historic_data[fdw]\nfdw = fdw.dropna().drop_duplicates()\nfdw_agg = fdw.groupby(\"year\")[\"frostdays_winter\"].agg(\"mean\").reset_index()\n\n\ntw = [\"year\", \"temp_winter\", \"longitude\", \"latitude\"]\ntw = historic_data[tw]\ntw = tw.dropna().drop_duplicates()\ntw_agg = tw.groupby(\"year\")[\"temp_winter\"].agg(\"mean\").reset_index()\n\n\nts = [\"year\", \"temp_summer\", \"longitude\", \"latitude\"]\nts = historic_data[ts]\nts = ts.dropna().drop_duplicates()\nts_agg = ts.groupby(\"year\")[\"temp_summer\"].agg(\"mean\").reset_index()\n\n\nta = [\"year\", \"temp_annual\", \"longitude\", \"latitude\"]\nta = historic_data[ta]\nta = ta.dropna().drop_duplicates()\nta_agg = ta.groupby(\"year\")[\"temp_annual\"].agg(\"mean\").reset_index()\n\nmts = [\"year\", \"maxtemp_summer\", \"longitude\", \"latitude\"]\nmts = historic_data[mts]\nmts = mts.dropna().drop_duplicates()\nmts_agg = mts.groupby(\"year\")[\"maxtemp_summer\"].agg(\"mean\").reset_index()\n\n\nmtw = [\"year\", \"mintemp_winter\", \"longitude\", \"latitude\"]\nmtw = historic_data[mtw]\nmtw = mtw.dropna().drop_duplicates()\nmtw_agg = mtw.groupby(\"year\")[\"mintemp_winter\"].agg(\"mean\").reset_index()\n\n\ncleaned_hist_subset = pd.merge(fdw_agg, tw_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, ts_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, ta_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, mts_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, mtw_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = cleaned_hist_subset.drop_duplicates()\ncleaned_hist_subset\n\n\ncleaned_hist_subset.columns\n\n\n\n\npx.line(cleaned_hist_subset, x = \"year\", y = ['frostdays_winter', 'temp_winter', 'temp_summer', 'temp_annual',\n       'maxtemp_summer', 'mintemp_winter'])"
  },
  {
    "objectID": "website/tabs/temperature/temperature.html#historical-data-cleaning",
    "href": "website/tabs/temperature/temperature.html#historical-data-cleaning",
    "title": "Current Data",
    "section": "",
    "text": "import pandas as pd \nimport seaborn as sns \n\nhistoric_data = pd.read_csv(\"../../../data/NABR_historic.csv\")\n\nhistoric_data.columns\n\ndata_colmap = {\n    \"long\" : \"longitude\",\n    \"lat\" : \"latitude\",\n    \"TimePeriod\" : \"time_period\",\n    \"RCP\" : \"rep_con_path\",\n    \"treecanopy\" : \"pct_treecanopy\", \n    \"Ann_Herb\" : \"pct_annual_herbcov\",\n    \"Bare\" : \"pct_bareground\",\n    \"Herb\" : \"pct_herbcov\",\n    \"Litter\" : \"pct_plantlittercov\",\n    \"Shrub\" : \"pct_shrubcov\",\n    \"DrySoilDays_Summer_whole\" : \"drysoildays_summer\",\n    \"Evap_Summer\" : \"evap_summer\", \n    \"ExtremeShortTermDryStress_Summer_whole\" : \"xtr_st_drysoilstress_summer\", \n    \"FrostDays_Winter\" : \"frostdays_winter\", \n    \"NonDrySWA_Summer_whole\" : \"nondry_swa_summer\",\n    \"PPT_Winter\" : \"precipitation_winter\", \n    \"PPT_Summer\" : \"precipitation_summer\",\n    \"PPT_Annual\" : \"precipitation_annual\", \n    \"T_Winter\" : \"temp_winter\",\n    \"T_Summer\" : \"temp_summer\", \n    \"T_Annual\" : \"temp_annual\", \n    \"Tmax_Summer\" : \"maxtemp_summer\", \n    \"Tmin_Winter\" : \"mintemp_winter\", \n    \"VWC_Winter_whole\" : \"volwater_winter\", \n    \"VWC_Spring_whole\" : \"volwater_spring\", \n    \"VWC_Summer_whole\" : \"volwater_summer\", \n    \"VWC_Fall_whole\" : \"volwater_fall\"\n}\n\nhistoric_data = historic_data.rename(columns=data_colmap)\nhistoric_data.columns\n\n\nimport plotly.express as px\nimport plotly \n\ntemp_subset_cols = [\"longitude\", \"latitude\", \"year\", \"frostdays_winter\", 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']\ntemp_subset_hist = historic_data[temp_subset_cols]\ntemp_subset_hist.head(10)\n\n\nfdw = [\"year\", \"frostdays_winter\", \"longitude\", \"latitude\"]\nfdw = historic_data[fdw]\nfdw = fdw.dropna().drop_duplicates()\nfdw_agg = fdw.groupby(\"year\")[\"frostdays_winter\"].agg(\"mean\").reset_index()\n\n\ntw = [\"year\", \"temp_winter\", \"longitude\", \"latitude\"]\ntw = historic_data[tw]\ntw = tw.dropna().drop_duplicates()\ntw_agg = tw.groupby(\"year\")[\"temp_winter\"].agg(\"mean\").reset_index()\n\n\nts = [\"year\", \"temp_summer\", \"longitude\", \"latitude\"]\nts = historic_data[ts]\nts = ts.dropna().drop_duplicates()\nts_agg = ts.groupby(\"year\")[\"temp_summer\"].agg(\"mean\").reset_index()\n\n\nta = [\"year\", \"temp_annual\", \"longitude\", \"latitude\"]\nta = historic_data[ta]\nta = ta.dropna().drop_duplicates()\nta_agg = ta.groupby(\"year\")[\"temp_annual\"].agg(\"mean\").reset_index()\n\nmts = [\"year\", \"maxtemp_summer\", \"longitude\", \"latitude\"]\nmts = historic_data[mts]\nmts = mts.dropna().drop_duplicates()\nmts_agg = mts.groupby(\"year\")[\"maxtemp_summer\"].agg(\"mean\").reset_index()\n\n\nmtw = [\"year\", \"mintemp_winter\", \"longitude\", \"latitude\"]\nmtw = historic_data[mtw]\nmtw = mtw.dropna().drop_duplicates()\nmtw_agg = mtw.groupby(\"year\")[\"mintemp_winter\"].agg(\"mean\").reset_index()\n\n\ncleaned_hist_subset = pd.merge(fdw_agg, tw_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, ts_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, ta_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, mts_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = pd.merge(cleaned_hist_subset, mtw_agg, on = \"year\", how = \"outer\")\ncleaned_hist_subset = cleaned_hist_subset.drop_duplicates()\ncleaned_hist_subset\n\n\ncleaned_hist_subset.columns\n\n\n\n\npx.line(cleaned_hist_subset, x = \"year\", y = ['frostdays_winter', 'temp_winter', 'temp_summer', 'temp_annual',\n       'maxtemp_summer', 'mintemp_winter'])"
  },
  {
    "objectID": "website/tabs/temperature/temperature.html#recent-data-cleaning",
    "href": "website/tabs/temperature/temperature.html#recent-data-cleaning",
    "title": "Current Data",
    "section": "Recent Data Cleaning",
    "text": "Recent Data Cleaning\n\nrecent_data = pd.read_csv(\"../../../data/nearterm_data_2020-2024.csv\")\nrecent_data = recent_data.rename(columns=data_colmap)\nrecent_data.head()\n\n\ntemp_subset_cols = [\"year\", \"frostdays_winter\", 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']\ntemp_subset_recent = recent_data[temp_subset_cols]\ntemp_subset_recent.head(10)\n\n\nfdw = [\"year\", \"frostdays_winter\", \"longitude\", \"latitude\"]\nfdw = recent_data[fdw]\nfdw = fdw.dropna().drop_duplicates()\nfdw_agg = fdw.groupby(\"year\")[\"frostdays_winter\"].agg(\"mean\").reset_index()\n\n\ntw = [\"year\", \"temp_winter\", \"longitude\", \"latitude\"]\ntw = recent_data[tw]\ntw = tw.dropna().drop_duplicates()\ntw_agg = tw.groupby(\"year\")[\"temp_winter\"].agg(\"mean\").reset_index()\n\n\nts = [\"year\", \"temp_summer\", \"longitude\", \"latitude\"]\nts = recent_data[ts]\nts = ts.dropna().drop_duplicates()\nts_agg = ts.groupby(\"year\")[\"temp_summer\"].agg(\"mean\").reset_index()\n\n\nta = [\"year\", \"temp_annual\", \"longitude\", \"latitude\"]\nta = recent_data[ta]\nta = ta.dropna().drop_duplicates()\nta_agg = ta.groupby(\"year\")[\"temp_annual\"].agg(\"mean\").reset_index()\n\nmts = [\"year\", \"maxtemp_summer\", \"longitude\", \"latitude\"]\nmts = recent_data[mts]\nmts = mts.dropna().drop_duplicates()\nmts_agg = mts.groupby(\"year\")[\"maxtemp_summer\"].agg(\"mean\").reset_index()\n\n\nmtw = [\"year\", \"mintemp_winter\", \"longitude\", \"latitude\"]\nmtw = recent_data[mtw]\nmtw = mtw.dropna().drop_duplicates()\nmtw_agg = mtw.groupby(\"year\")[\"mintemp_winter\"].agg(\"mean\").reset_index()\n\n\ncleaned_recent_subset = pd.merge(fdw_agg, tw_agg, on = \"year\", how = \"outer\")\ncleaned_recent_subset = pd.merge(cleaned_recent_subset, ts_agg, on = \"year\", how = \"outer\")\ncleaned_recent_subset = pd.merge(cleaned_recent_subset, ta_agg, on = \"year\", how = \"outer\")\ncleaned_recent_subset = pd.merge(cleaned_recent_subset, mts_agg, on = \"year\", how = \"outer\")\ncleaned_recent_subset = pd.merge(cleaned_recent_subset, mtw_agg, on = \"year\", how = \"outer\")\ncleaned_recent_subset = cleaned_recent_subset.drop_duplicates()\ncleaned_recent_subset\n\n\ncleaned_recent_subset.columns"
  },
  {
    "objectID": "website/tabs/temperature/temperature.html#merging-data-sets",
    "href": "website/tabs/temperature/temperature.html#merging-data-sets",
    "title": "Current Data",
    "section": "Merging Data Sets",
    "text": "Merging Data Sets\n\ncleaned_temp_subset = pd.merge(cleaned_hist_subset, cleaned_recent_subset, on = ['year', 'frostdays_winter', 'temp_winter', 'temp_summer', 'temp_annual',\n       'maxtemp_summer', 'mintemp_winter'], how = \"outer\")\ncleaned_temp_subset\n\n\ncleaned_temp_subset.to_csv(\"../../../data/cleaned_temp_subset.csv\")\n\n\n```{ojs}\nd3 = require('d3@7')\ndata = d3.csv(../../../data/cleaned_temp_subset.csv)\ndata_table = aq.from(data)\n\nimport {SummaryTable} from \"@observablehq/summary-table\"\nSummaryTable(data_table)\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 1, column 15)Unexpected token\n\n\n\n\n\n\n\n\n\nMerged Line Graph\n\npx.line(cleaned_temp_subset, x = \"year\", y = ['frostdays_winter', 'temp_winter', 'temp_summer', 'temp_annual',\n       'maxtemp_summer', 'mintemp_winter'])"
  },
  {
    "objectID": "website/tabs/temperature/temperature.html#dash-app",
    "href": "website/tabs/temperature/temperature.html#dash-app",
    "title": "Current Data",
    "section": "Dash App",
    "text": "Dash App\n\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport pandas as pd\nimport dash_bootstrap_components as dbc\nimport plotly.express as px\n\napp = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n\n# Load the data\ncleaned_temp_subset = pd.read_csv(\"../../../data/cleaned_temp_subset.csv\")\n\n# Extract unique years for the dropdown options\nyears = [{'label': str(year), 'value': year} for year in cleaned_temp_subset[\"year\"].unique()]\n\n# Define the layout of the app\napp.layout = html.Div([\n\n    html.H1(\"Temperature Data\", style={\"text-align\": \"center\"}),\n\n    dcc.Dropdown(id=\"select_year\", \n                 options=years,\n                 multi=True, \n                 value=[1980], \n                 style={\"width\": \"40%\"}), \n\n    html.Div(id=\"output_container\", children=[]), \n    html.Br(), \n\n    dcc.Graph(id=\"temp_map\", figure={})\n])\n\n@app.callback(\n    Output(component_id='output_container', component_property='children'),\n    Output(component_id='temp_map', component_property='figure'),\n    Input(component_id='select_year', component_property='value')\n)\ndef update_graph(selected_years):\n    # Filter data based on selected years\n    filtered_df = cleaned_temp_subset[cleaned_temp_subset[\"year\"].isin(selected_years)]\n\n    # Transform the data to long format for Plotly Express\n    long_df = filtered_df.melt(id_vars=[\"year\"], \n                               value_vars=['temp_winter', 'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter'],\n                               var_name=\"Metric\", \n                               value_name=\"Value\")\n\n    # Create a bar plot using Plotly Express\n    fig = px.bar(long_df, x=\"year\", y=\"Value\", color=\"Metric\",\n                 title=\"Temperature Data for Selected Years\",\n                 labels={'Value': 'Average Temperature (ºC)', 'Metric': 'Metrics'},\n                 barmode='group')\n\n    # Output message\n    container = f\"The year(s) selected by user: {', '.join(map(str, selected_years))}\"\n\n    return container, fig\n\nif __name__ == \"__main__\":\n    app.run_server(port=8051)"
  },
  {
    "objectID": "website/tabs/data/data.html",
    "href": "website/tabs/data/data.html",
    "title": "Returning Student Scholarship Application",
    "section": "",
    "text": "1+1"
  },
  {
    "objectID": "website/tabs/dryness/dryness.html",
    "href": "website/tabs/dryness/dryness.html",
    "title": "Returning Student Scholarship Application",
    "section": "",
    "text": "import pandas as pd \n\ndata = pd.read_csv(\"../../../data/NABR_historic.csv\")\n\ndata_colmap = {\n    \"long\" : \"longitude\",\n    \"lat\" : \"latitude\",\n    \"TimePeriod\" : \"time_period\",\n    \"RCP\" : \"rep_con_path\",\n    \"treecanopy\" : \"pct_treecanopy\", \n    \"Ann_Herb\" : \"pct_annual_herbcov\",\n    \"Bare\" : \"pct_bareground\",\n    \"Herb\" : \"pct_herbcov\",\n    \"Litter\" : \"pct_plantlittercov\",\n    \"Shrub\" : \"pct_shrubcov\",\n    \"DrySoilDays_Summer_whole\" : \"drysoildays_summer\",\n    \"Evap_Summer\" : \"evap_summer\", \n    \"ExtremeShortTermDryStress_Summer_whole\" : \"xtr_st_drysoilstress_summer\", \n    \"FrostDays_Winter\" : \"frostdays_winter\", \n    \"NonDrySWA_Summer_whole\" : \"nondry_swa_summer\",\n    \"PPT_Winter\" : \"precipitation_winter\", \n    \"PPT_Summer\" : \"precipitation_summer\",\n    \"PPT_Annual\" : \"precipitation_annual\", \n    \"T_Winter\" : \"temp_winter\",\n    \"T_Summer\" : \"temp_summer\", \n    \"T_Annual\" : \"temp_annual\", \n    \"Tmax_Summer\" : \"maxtemp_summer\", \n    \"Tmin_Winter\" : \"mintemp_winter\", \n    \"VWC_Winter_whole\" : \"volwater_winter\", \n    \"VWC_Spring_whole\" : \"volwater_spring\", \n    \"VWC_Summer_whole\" : \"volwater_summer\", \n    \"VWC_Fall_whole\" : \"volwater_fall\"\n}\n\ndata = data.rename(columns=data_colmap)\n\nsoil_data_cols = ['year', 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer'] \n\nsoil_data = data[soil_data_cols]\n\nsoil_data_agg = soil_data.groupby(\"year\")[['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer']].agg(\"mean\").reset_index()\n\n\nIndex(['longitude', 'latitude', 'year', 'time_period', 'rep_con_path',\n       'scenario', 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer',\n       'frostdays_winter', 'nondry_swa_summer', 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter',\n       'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall'],\n      dtype='object')\n\n\n\n\n\n\n\n\n\n\n\n\nyear\npct_treecanopy\npct_annual_herbcov\npct_bareground\npct_herbcov\npct_plantlittercov\npct_shrubcov\ndrysoildays_summer\nevap_summer\nxtr_st_drysoilstress_summer\n\n\n\n\n0\n1980\n0\n0\n84\n5\n11\n7\nNaN\nNaN\nNaN\n\n\n1\n1980\n0\n0\n84\n5\n11\n7\nNaN\nNaN\nNaN\n\n\n2\n1980\n0\n0\n84\n5\n11\n7\nNaN\nNaN\nNaN\n\n\n3\n1980\n0\n0\n84\n5\n11\n7\nNaN\nNaN\nNaN\n\n\n4\n1980\n0\n0\n84\n5\n11\n7\n0.0\n1.559807\n36.16\n\n\n\n\n\n\n\n\nimport plotly.express as px\n\npx.scatter(soil_data_agg, x = \"year\", y = ['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer'], trendline = \"ols\")\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport plotly.express as px\nimport pandas as pd\n\napp = dash.Dash(__name__)\n\ncolumns = soil_data_agg.columns\n\napp.layout = html.Div([\n    html.H1(\"Interactive Soil Data Graph\"),\n    \n    html.Div([\n        html.Label(\"Select Y-axis:\"),\n        dcc.Dropdown(\n            id='y-axis-dropdown',\n            options=[{'label': col, 'value': col} for col in columns],\n            value='pct_treecanopy', \n            multi = True\n        ),\n    ]),\n    \n    dcc.Graph(id='scatter-plot')\n])\n\n@app.callback(\n    Output('scatter-plot', 'figure'),\n     Input('y-axis-dropdown', 'value')\n)\ndef update_graph(y_axis):\n    fig = px.line(soil_data_agg, x=\"year\", y=y_axis, title=f'{y_axis} vs Year')\n    return fig\n\nif __name__ == '__main__':\n    app.run_server(debug=True, port = 8052)\n\n\n        \n        \n\n\n\ntemp_data = pd.read_csv(\"../../../data/cleaned_temp_subset.csv\")\n\ntemp_data = temp_data.drop(columns=\"Unnamed: 0\")\n\ntemp_soil_data = pd.merge(temp_data, soil_data_agg, on = \"year\", how = \"outer\")\n\n\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport plotly.express as px\nimport pandas as pd\n\napp = dash.Dash(__name__)\n\ncolumns = temp_soil_data.columns\n\napp.layout = html.Div([\n    html.H1(\"Interactive Temperature and Soil Data Graph\"),\n    \n    html.Div([\n        html.Label(\"Select Y-axis:\"),\n        dcc.Dropdown(\n            id='y-axis-dropdown',\n            options=[{'label': col, 'value': col} for col in columns],\n            value='pct_treecanopy', \n            multi = True\n        ),\n    ]),\n    \n    dcc.Graph(id='scatter-plot')\n])\n\n@app.callback(\n    Output('scatter-plot', 'figure'),\n     Input('y-axis-dropdown', 'value')\n)\ndef update_graph(y_axis):\n    fig = px.line(temp_soil_data, x=\"year\", y=y_axis, title=f'{y_axis} vs Year')\n    return fig\n\nif __name__ == '__main__':\n    app.run_server(debug=True, port = 8053)"
  },
  {
    "objectID": "website/tabs/introduction/introduction.html",
    "href": "website/tabs/introduction/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Over the past few decades, we as a human race have watched our technology get more developed, our methods of production more efficient, and our creativity flourish. We must ask, at what cost does this come at? One of many answers is climate change. Governments, officials, and high up personnel at huge companies make the decisions that affect our climate.\nWhile humans can advocate for themselves and the state and safety of our world, animals and insects can’t. Animals and insects face the unjust consequences of human’s actions, and it is important that we stand to protect them, as this earth was their home before it was ours.\nThe four corners region, where Utah, Arizona, Colorado, and New Mexico meet, is a unique area in the United States. It is an area covered in desert, with temperatures that swing on the warmer side."
  },
  {
    "objectID": "website/tabs/introduction/introduction.html#introduction",
    "href": "website/tabs/introduction/introduction.html#introduction",
    "title": "Introduction",
    "section": "",
    "text": "Over the past few decades, we as a human race have watched our technology get more developed, our methods of production more efficient, and our creativity flourish. We must ask, at what cost does this come at? One of many answers is climate change. Governments, officials, and high up personnel at huge companies make the decisions that affect our climate.\nWhile humans can advocate for themselves and the state and safety of our world, animals and insects can’t. Animals and insects face the unjust consequences of human’s actions, and it is important that we stand to protect them, as this earth was their home before it was ours.\nThe four corners region, where Utah, Arizona, Colorado, and New Mexico meet, is a unique area in the United States. It is an area covered in desert, with temperatures that swing on the warmer side."
  },
  {
    "objectID": "code/cleaning.html#temperature-data-subset",
    "href": "code/cleaning.html#temperature-data-subset",
    "title": "Temperature Data Subset",
    "section": "",
    "text": "import pandas as pd \nimport seaborn as sns \n\nhistoric_data = pd.read_csv(\"../data/NABR_historic.csv\")\n\nhistoric_data.columns\n\ndata_colmap = {\n    \"long\" : \"longitude\",\n    \"lat\" : \"latitude\",\n    \"TimePeriod\" : \"time_period\",\n    \"RCP\" : \"rep_con_path\",\n    \"treecanopy\" : \"pct_treecanopy\", \n    \"Ann_Herb\" : \"pct_annual_herbcov\",\n    \"Bare\" : \"pct_bareground\",\n    \"Herb\" : \"pct_herbcov\",\n    \"Litter\" : \"pct_plantlittercov\",\n    \"Shrub\" : \"pct_shrubcov\",\n    \"DrySoilDays_Summer_whole\" : \"drysoildays_summer\",\n    \"Evap_Summer\" : \"evap_summer\", \n    \"ExtremeShortTermDryStress_Summer_whole\" : \"xtr_st_drysoilstress_summer\", \n    \"FrostDays_Winter\" : \"frostdays_winter\", \n    \"NonDrySWA_Summer_whole\" : \"nondry_swa_summer\",\n    \"PPT_Winter\" : \"precipitation_winter\", \n    \"PPT_Summer\" : \"precipitation_summer\",\n    \"PPT_Annual\" : \"precipitation_annual\", \n    \"T_Winter\" : \"temp_winter\",\n    \"T_Summer\" : \"temp_summer\", \n    \"T_Annual\" : \"temp_annual\", \n    \"Tmax_Summer\" : \"maxtemp_summer\", \n    \"Tmin_Winter\" : \"mintemp_winter\", \n    \"VWC_Winter_whole\" : \"volwater_winter\", \n    \"VWC_Spring_whole\" : \"volwater_spring\", \n    \"VWC_Summer_whole\" : \"volwater_summer\", \n    \"VWC_Fall_whole\" : \"volwater_fall\"\n}\n\nhistoric_data = historic_data.rename(columns=data_colmap)\n\n\ntemp_subset_cols = [\"longitude\", \"latitude\", \"year\", \"frostdays_winter\", 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']\ntemp_subset_hist = historic_data[temp_subset_cols]\n\ntemp_data_agg = temp_subset_hist.groupby(\"year\")[['temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']].agg(\"mean\").reset_index()\n\nrecent_data = pd.read_csv(\"../data/nearterm_data_2020-2024.csv\")\nrecent_data = recent_data.rename(columns=data_colmap)\n\ntemp_subset_cols = [\"year\", \"frostdays_winter\", 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']\ntemp_subset_recent = recent_data[temp_subset_cols]\n\ncleaned_recent_subset = temp_subset_recent.groupby(\"year\")[['temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter']].agg(\"mean\").reset_index()\n\ncleaned_temp_subset = pd.merge(temp_data_agg, cleaned_recent_subset, on = ['year', 'temp_winter', 'temp_summer', 'temp_annual',\n       'maxtemp_summer', 'mintemp_winter'], how = \"outer\")\ncleaned_temp_subset.to_csv(\"../data/cleaned_temp_subset.csv\")"
  },
  {
    "objectID": "code/cleaning.html#soil-data-subset",
    "href": "code/cleaning.html#soil-data-subset",
    "title": "Temperature Data Subset",
    "section": "Soil Data Subset",
    "text": "Soil Data Subset\n\nhistoric_data.columns\n\nIndex(['longitude', 'latitude', 'year', 'time_period', 'rep_con_path',\n       'scenario', 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer',\n       'frostdays_winter', 'nondry_swa_summer', 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter',\n       'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall'],\n      dtype='object')\n\n\n\nsoil_data_cols = ['year', 'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer', 'nondry_swa_summer', 'frostdays_winter'] \n\nsoil_data_hist = historic_data[soil_data_cols]\nsoil_data_recent = recent_data[soil_data_cols]\n\nsoil_data_hist_agg = soil_data_hist.groupby(\"year\")[['drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer', 'frostdays_winter', 'nondry_swa_summer']].agg(\"mean\").reset_index()\n\nsoil_data_recent_agg = soil_data_recent.groupby(\"year\")[['drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer', 'frostdays_winter', 'nondry_swa_summer']].agg(\"mean\").reset_index()\n\nsoil_data_agg = pd.merge(soil_data_hist_agg, soil_data_recent_agg, on = ['year', 'drysoildays_summer', 'evap_summer', 'frostdays_winter', 'xtr_st_drysoilstress_summer', 'nondry_swa_summer'], how = \"outer\")\n\nsoil_data_agg.to_csv(\"../data/soil_data.csv\")"
  },
  {
    "objectID": "code/cleaning.html#coverage-data-subset",
    "href": "code/cleaning.html#coverage-data-subset",
    "title": "Temperature Data Subset",
    "section": "Coverage Data Subset",
    "text": "Coverage Data Subset\n\ncoverage_cols_agg = [\"year\", 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov']\n\ncoverage_cols_reg = [\"latitude\", \"longitude\", \"year\", 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov']\n\ncoverage_data_hist = historic_data[coverage_cols_agg]\ncoverage_data_recent = recent_data[coverage_cols_agg]\n\ncoverage_data_nonagg_hist = historic_data[coverage_cols_reg]\ncoverage_data_nonagg_recent = recent_data[coverage_cols_reg]\n\ncoverage_data_agg_hist = coverage_data_hist.groupby(\"year\")[['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov']].agg(\"mean\").reset_index()\n\ncoverage_data_agg_recent = coverage_data_recent.groupby(\"year\")[['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov']].agg(\"mean\").reset_index()\n\ncoverage_data_agg = pd.merge(coverage_data_agg_hist, coverage_data_agg_recent, on = [\"year\", 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov'], how = \"outer\")\ncoverage_data_agg.to_csv(\"../data/coverage_data_agg.csv\")\n\ncoverage_data_nonagg = pd.merge(coverage_data_nonagg_hist, coverage_data_nonagg_recent, on = [\"latitude\", \"longitude\", \"year\", 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov'], how = \"outer\")\ncoverage_data_nonagg.to_csv(\"../data/coverage_data_reg.csv\")"
  },
  {
    "objectID": "code/cleaning.html#rain-data-subset",
    "href": "code/cleaning.html#rain-data-subset",
    "title": "Temperature Data Subset",
    "section": "Rain Data Subset",
    "text": "Rain Data Subset\n\nrain_cols_agg = [\"year\", 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall']\n\nrain_cols_reg = [\"year\", 'latitude', 'longitude', 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall']\n\nrain_hist_agg = historic_data[rain_cols_agg]\nrain_recent_agg = recent_data[rain_cols_agg]\n\nrain_hist_reg = historic_data[rain_cols_reg]\nrain_recent_reg = recent_data[rain_cols_reg]\n\nrain_hist_agg = rain_hist_agg.groupby(\"year\")[['precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall']].agg('mean').reset_index()\n\nrain_recent_agg = rain_recent_agg.groupby(\"year\")[['precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall']].agg('mean').reset_index()\n\nrain_data_agg = pd.merge(rain_hist_agg, rain_recent_agg, on = [\"year\", 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall'], how = \"outer\")\nrain_data_agg.to_csv(\"../data/rain_data_agg.csv\")\n\nrain_data_reg = pd.merge(rain_hist_reg, rain_recent_reg, on = [\"year\", 'latitude', 'longitude', 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall'], how = \"outer\")\nrain_data_reg.to_csv(\"../data/rain_data_reg.csv\")"
  },
  {
    "objectID": "website/tabs/cottontails/cottontails.html",
    "href": "website/tabs/cottontails/cottontails.html",
    "title": "Cottontails",
    "section": "",
    "text": "Cottontails are among the few of the animals found to the Four Corners Region. Cottontails are caring by nature, with mothers often having between three to eight babies in each litter, and having three to four litters per year. With potentially up to twenty-four babies to care for, the last thing Cottontails need to worry about is their environment and whether or not their environment will provide for them.\nCottontails prefer dry, well-drained soils, but not extremely dry, abudantly low vegetation, low to moderate rainfall, and are adaptable to all temperatures. As climate change brings more dramatic rains and extremely dry soil, the cottontail’s preferred habitat is threatened.\nAs climate change continues to threaten, cottontails like Martha, pictured to the right, struggle to raise and provide for their babies.\n\nExtremely Dry Soil\nBelow is a correlation matrix to show what is causing the soil to be as dry as it is. The increased temperatures that are brought by climate change are the main cause.\n\n\nCode\nimport seaborn as sns \nimport plotly.express as px\nimport pandas as pd \n\nhist_data_agg = pd.read_csv(\"../../../data/NABR_historic.csv\")\ndata_colmap = {\n    \"long\" : \"longitude\",\n    \"lat\" : \"latitude\",\n    \"TimePeriod\" : \"time_period\",\n    \"RCP\" : \"rep_con_path\",\n    \"treecanopy\" : \"pct_treecanopy\", \n    \"Ann_Herb\" : \"pct_annual_herbcov\",\n    \"Bare\" : \"pct_bareground\",\n    \"Herb\" : \"pct_herbcov\",\n    \"Litter\" : \"pct_plantlittercov\",\n    \"Shrub\" : \"pct_shrubcov\",\n    \"DrySoilDays_Summer_whole\" : \"drysoildays_summer\",\n    \"Evap_Summer\" : \"evap_summer\", \n    \"ExtremeShortTermDryStress_Summer_whole\" : \"xtr_st_drysoilstress_summer\", \n    \"FrostDays_Winter\" : \"frostdays_winter\", \n    \"NonDrySWA_Summer_whole\" : \"nondry_swa_summer\",\n    \"PPT_Winter\" : \"precipitation_winter\", \n    \"PPT_Summer\" : \"precipitation_summer\",\n    \"PPT_Annual\" : \"precipitation_annual\", \n    \"T_Winter\" : \"temp_winter\",\n    \"T_Summer\" : \"temp_summer\", \n    \"T_Annual\" : \"temp_annual\", \n    \"Tmax_Summer\" : \"maxtemp_summer\", \n    \"Tmin_Winter\" : \"mintemp_winter\", \n    \"VWC_Winter_whole\" : \"volwater_winter\", \n    \"VWC_Spring_whole\" : \"volwater_spring\", \n    \"VWC_Summer_whole\" : \"volwater_summer\", \n    \"VWC_Fall_whole\" : \"volwater_fall\"\n}\nhist_data_agg = hist_data_agg.rename(columns = data_colmap)\n\ncols_to_drop = ['longitude', 'latitude', 'time_period' ,'scenario', 'rep_con_path']\nhist_data_agg = hist_data_agg.drop(columns=cols_to_drop)\n\nhist_data_agg = hist_data_agg.groupby(\"year\")[['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer',\n       'frostdays_winter', 'nondry_swa_summer', 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter',\n       'volwater_winter', 'volwater_spring']].agg(\"mean\").reset_index()\n\n#px.scatter(hist_data_agg, x = \"pct_bareground\", y = [\"temp_summer\", 'temp_annual', 'maxtemp_summer'], trendline = \"ols\", template = 'ggplot2')\nhist_data_agg_ny = hist_data_agg.drop(columns = \"year\")\ncorrelation_matrix = hist_data_agg_ny.corr()\ndry_soil_corr = correlation_matrix['xtr_st_drysoilstress_summer']\ndry_soil_corr_sorted = dry_soil_corr.sort_values(ascending=False)\n\nimport plotly.graph_objects as go\n\nfig = go.Figure(data=go.Heatmap(\n    z=correlation_matrix.values,\n    x=correlation_matrix.columns,\n    y=correlation_matrix.columns,\n    colorscale='Reds',\n    zmid=0\n))\n\nfig.update_layout(\n    title='Correlation Matrix Heatmap',\n    xaxis_nticks=36, \n    template = 'ggplot2'\n)\n\nfig.show()\n\n\n                                                \nFigure 1, A correlation matrix showing the correlation between each variable and extreme short term dry soil in the summer.\n\n\nWhile dry soil allows for Martha to burrow and nest with her babies in a structure that won’t collapse, extremely dry soil often means low vegetation, and leaves her and her children more visible to predators.\n\n\nCode\n# px.scatter(hist_data_agg, x = \"maxtemp_summer\", y = 'xtr_st_drysoilstress_summer', trendline = \"ols\", template = \"ggplot2\", title = \"Extreme Dry Soil Stress vs Max Temp in Summer\")\n\n\n\n\nCode\nimport matplotlib as plt\ng = sns.pairplot(hist_data_agg, vars=['evap_summer', 'temp_summer', 'precipitation_summer', 'xtr_st_drysoilstress_summer'])\n\nfor ax in g.axes.flatten():\n    if ax.get_xlabel() in ['evap_summer', 'temp_summer', 'precipitation_summer', 'drysoildays_summer'] and ax.get_ylabel() in ['evap_summer', 'temp_summer', 'precipitation_summer', 'drysoildays_summer']:\n        sns.regplot(\n            x=ax.get_xlabel(), \n            y=ax.get_ylabel(), \n            data=hist_data_agg, \n            ax=ax, \n            scatter=False\n        )\n\ng\n\n\n\n\n\n\n\n\n\n\n\nCode\ng = sns.pairplot(hist_data_agg, vars=['evap_summer', 'temp_summer', 'precipitation_summer', 'drysoildays_summer'])\ng\n\n\n\n\n\n\n\n\n\n\n\nCode\nhist_data_melted = pd.melt(hist_data_agg, id_vars = \"year\", var_name=\"Variable\", value_name=\"Value\")\n\n\nThe increase in summer temperature causes the soil to be especially dry, harming\n\n\nAbundant Low Vegetation and Coverage"
  },
  {
    "objectID": "website/tabs/overview/overview.html",
    "href": "website/tabs/overview/overview.html",
    "title": "Temperature Trends",
    "section": "",
    "text": "Code\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport pandas as pd\nimport plotly.express as px\n\napp = dash.Dash(__name__)\n\ncleaned_temp_subset = pd.read_csv(\"../../../data/cleaned_temp_subset.csv\")\ncleaned_temp_subset = cleaned_temp_subset.drop(columns=\"Unnamed: 0\")\n\noptions = [{'label': col, 'value': col} for col in cleaned_temp_subset.columns if col not in ['year', \"frostdays_winter\"]]\n\napp.layout = html.Div([\n\n    html.H1(\"Temperature Data\", style={\"text-align\": \"center\"}),\n\n    dcc.Dropdown(id=\"dropdown\", \n                 options=options,\n                 multi=True, \n                 value=[\"temp_winter\"], \n                 style={\"width\": \"40%\"}), \n\n    html.Div(id=\"output_container\", children=[]), \n    html.Br(), \n\n    dcc.Graph(id=\"temp_map\", figure={})\n])\n\n@app.callback(\n    Output(component_id='output_container', component_property='children'),\n    Output(component_id='temp_map', component_property='figure'),\n    Input(component_id='dropdown', component_property='value')\n)\ndef update_graph(selected_options):\n    if not selected_options:\n        return \"No data selected\", {}\n\n    long_df = cleaned_temp_subset.melt(id_vars=[\"year\"], \n                                       value_vars=selected_options,\n                                       var_name=\"Metric\", \n                                       value_name=\"Value\")\n\n    fig = px.line_polar(long_df, r=\"Value\", theta=\"year\", color=\"Metric\",\n                        title=\"Temperature Data for Selected Metrics\",\n                        labels={'Value': 'Average Temperature (ºC)', 'year': 'Year', 'Metric': 'Metrics'},\n                        line_close=False, \n                        template=\"ggplot2\", \n                        color_discrete_sequence=px.colors.qualitative.Bold)\n\n    fig.update_layout(\n        polar=dict(\n            angularaxis=dict(\n                type='category',\n                categoryorder='category ascending',\n                tickvals=[str(year) for year in cleaned_temp_subset['year'].unique()],\n                ticktext=[str(year) for year in cleaned_temp_subset['year'].unique()],\n                ticks='outside',\n                ticklen=10,\n                tickfont=dict(size=8),\n                rotation=90  \n            )\n        )\n    )\n\n    container = f\"The metrics selected by user: {', '.join(selected_options)}\"\n\n    return container, fig\n\nif __name__ == \"__main__\":\n    app.run_server(port=8051, debug=True, use_reloader=False)"
  },
  {
    "objectID": "website/tabs/overview/overview.html#subsetted-data-tables",
    "href": "website/tabs/overview/overview.html#subsetted-data-tables",
    "title": "Current Data",
    "section": "",
    "text": "```{ojs}\nd3 = require('d3@7')\ndata = d3.csv(../../../data/cleaned_temp_subset.csv)\ndata_table = aq.from(data)\n\nimport {SummaryTable} from \"@observablehq/summary-table\"\nSummaryTable(data_table)\n```\n\n\n\n\n\n\n\nOJS Syntax Error (line 1, column 15)Unexpected token"
  },
  {
    "objectID": "website/tabs/overview/overview.html#temperature-trends",
    "href": "website/tabs/overview/overview.html#temperature-trends",
    "title": "Subsetted Data Tables",
    "section": "Temperature Trends",
    "text": "Temperature Trends\n\n\nCode\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport pandas as pd\nimport plotly.express as px\n\napp = dash.Dash(__name__)\n\ncleaned_temp_subset = pd.read_csv(\"../../../data/cleaned_temp_subset.csv\")\ncleaned_temp_subset = cleaned_temp_subset.drop(columns=\"Unnamed: 0\")\n\noptions = [{'label': col, 'value': col} for col in cleaned_temp_subset.columns if col not in ['year', \"frostdays_winter\"]]\n\napp.layout = html.Div([\n\n    html.H1(\"Temperature Data\", style={\"text-align\": \"center\"}),\n\n    dcc.Dropdown(id=\"dropdown\", \n                 options=options,\n                 multi=True, \n                 value=[\"temp_winter\"], \n                 style={\"width\": \"40%\"}), \n\n    html.Div(id=\"output_container\", children=[]), \n    html.Br(), \n\n    dcc.Graph(id=\"temp_map\", figure={})\n])\n\n@app.callback(\n    Output(component_id='output_container', component_property='children'),\n    Output(component_id='temp_map', component_property='figure'),\n    Input(component_id='dropdown', component_property='value')\n)\ndef update_graph(selected_options):\n    if not selected_options:\n        return \"No data selected\", {}\n\n    long_df = cleaned_temp_subset.melt(id_vars=[\"year\"], \n                                       value_vars=selected_options,\n                                       var_name=\"Metric\", \n                                       value_name=\"Value\")\n\n    fig = px.line_polar(long_df, r=\"Value\", theta=\"year\", color=\"Metric\",\n                        title=\"Temperature Data for Selected Metrics\",\n                        labels={'Value': 'Average Temperature (ºC)', 'year': 'Year', 'Metric': 'Metrics'},\n                        line_close=False, \n                        template=\"ggplot2\", \n                        color_discrete_sequence=px.colors.qualitative.Bold)\n\n    fig.update_layout(\n        polar=dict(\n            angularaxis=dict(\n                type='category',\n                categoryorder='category ascending',\n                tickvals=[str(year) for year in cleaned_temp_subset['year'].unique()],\n                ticktext=[str(year) for year in cleaned_temp_subset['year'].unique()],\n                ticks='outside',\n                ticklen=10,\n                tickfont=dict(size=8),\n                rotation=90  \n            )\n        )\n    )\n\n    container = f\"The metrics selected by user: {', '.join(selected_options)}\"\n\n    return container, fig\n\nif __name__ == \"__main__\":\n    app.run_server(port=8054)\n\n\n\n        \n        \n\n\n\nCoverage Data\n\n\nCode\nimport plotly.express as px\nimport pandas as pd \n\ncoverage_data_agg = pd.read_csv(\"../../../data/coverage_data_agg.csv\")\ncoverage_data_agg = coverage_data_agg.drop(columns=\"Unnamed: 0\")\n\nmelted_coverage_agg = pd.melt(coverage_data_agg, id_vars=\"year\", value_vars=['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov'])\n\ncoverage_data_agg_renamed = coverage_data_agg.rename(columns={\n    \"pct_treecanopy\": \"Tree Canopy Coverage (%)\", \n    'pct_annual_herbcov': \"Annual Herbaceous Coverage (%)\", \n    'pct_bareground': \"Bare Ground (%)\", \n    \"pct_herbcov\": \"Herbaceous Coverage (%)\",\n    \"pct_plantlittercov\": \"Plant Litter Coverage (%)\",\n    \"pct_shrubcov\": \"Shrub Coverage (%)\"\n})\n\ncoverage_data_long = coverage_data_agg_renamed.melt(id_vars=[\"year\"], var_name=\"Coverage Type\", value_name=\"Percentage\")\n\n# fig = px.scatter(coverage_data_long, x=\"year\", y=\"Percentage\", color=\"Coverage Type\", title=\"Coverage Data Trends\", color_discrete_sequence=px.colors.qualitative.Bold\n# , trendline = \"ols\", template = \"ggplot2\")\n\n# fig.show()"
  },
  {
    "objectID": "website/tabs/overview/overview.html#rain-data",
    "href": "website/tabs/overview/overview.html#rain-data",
    "title": "Temperature Trends",
    "section": "Rain Data",
    "text": "Rain Data\n\n\nCode\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport pandas as pd\nimport plotly.express as px\n\napp = dash.Dash(__name__)\n\nrain_data_reg = pd.read_csv(\"../../../data/rain_data_reg.csv\")\n\noptions = [{'label': col, 'value': col} for col in rain_data_reg.columns if col not in ['year', 'latitude', 'longitude', \"Unnamed: 0\"]]\n\napp.layout = html.Div([\n\n    html.H1(\"Rain Data\", style={\"text-align\": \"center\"}),\n\n    dcc.Dropdown(id=\"dropdown\", \n                 options=options,\n                 multi=True, \n                 value=[\"precipitation_winter\"], \n                 style={\"width\": \"40%\"}), \n\n    html.Div(id=\"output_container\", children=[]), \n    html.Br(), \n\n    dcc.Graph(id=\"rain_map\", figure={})\n])\n\n@app.callback(\n    Output(component_id='output_container', component_property='children'),\n    Output(component_id='rain_map', component_property='figure'),\n    Input(component_id='dropdown', component_property='value')\n)\ndef update_graph(selected_options):\n    if not selected_options:\n        return \"No data selected\", {}\n\n    long_df = rain_data_reg.melt(id_vars=[\"year\", \"latitude\", \"longitude\"], \n                                 value_vars=selected_options,\n                                 var_name=\"Metric\", \n                                 value_name=\"Value\")\n    \n    vmin = long_df[\"Value\"].min()\n    vmax = long_df[\"Value\"].max()\n\n    fig = px.scatter_geo(long_df, \n                         lat='latitude', \n                         lon='longitude', \n                         color='Value',\n                         animation_frame='year',\n                         animation_group = \"Metric\", \n                         scope='usa', \n                         title='Rain Data Over Time',\n                         facet_col='Metric',\n                         height=600,\n                         range_color=[vmin, vmax], \n                         template = \"ggplot2\")\n    \n    fig.update_geos(\n        center={\"lat\": 37.5, \"lon\": -110},  \n        projection_scale=30  \n    )\n\n    fig.update_layout(coloraxis_colorbar=dict(\n        title=\"Water (mm)\"  \n    ))\n\n\n    container = f\"The metrics selected by user: {', '.join(selected_options)}\"\n\n    return container, fig\n\nif __name__ == \"__main__\":\n    app.run_server(host='0.0.0.0', port=8051)"
  },
  {
    "objectID": "website/tabs/overview/overview.html#soil-data",
    "href": "website/tabs/overview/overview.html#soil-data",
    "title": "Temperature Trends",
    "section": "Soil Data",
    "text": "Soil Data\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nsoil_data_agg = pd.read_csv(\"../../../data/soil_data.csv\")\nsoil_data_agg = soil_data_agg.drop(columns = \"Unnamed: 0\")\nsoil_data_agg = soil_data_agg.rename(columns = {\n    'year': 'Year',\n    'drysoildays_summer': \"Dry Soil Days (Summer)\", \n    'evap_summer': \"Evaporation (Summer)\", \n    'xtr_st_drysoilstress_summer': \"Extreme Short Term Dry Soil Sress Days (Summer)\", \n    'frostdays_winter': \"Frost Days (Winter)\",\n    'nondry_swa_summer': \"Non-Dry Soil Water Availability (Summer)\"\n})\n\nsoil_data_melted = pd.melt(soil_data_agg, id_vars=[\"Year\"], var_name = \"Variable\", value_name = \"Value\")\nsoil_data_melted['Value'] = soil_data_melted['Value'].round(2)\n\nsns.lmplot(x=\"Year\", y=\"Value\", hue=\"Variable\", data=soil_data_melted, palette=\"bright\",\n           scatter_kws={\"s\": 50, \"alpha\": 0.7}, legend_out=True, aspect=1)\nplt.title(\"Soil Data Over Time\")\nplt.xlabel(\"Year\")\nplt.ylabel(\"Value\")\n\n\nText(75.24659722222225, 0.5, 'Value')"
  },
  {
    "objectID": "website/tabs/home/index.html",
    "href": "website/tabs/home/index.html",
    "title": "Returning Student Scholarship Application",
    "section": "",
    "text": "1+1"
  },
  {
    "objectID": "website/tabs/black_bears/bears.html",
    "href": "website/tabs/black_bears/bears.html",
    "title": "Returning Student Scholarship Application",
    "section": "",
    "text": "Warmer temperatures also seem to be the culprit of black bears’ problems. Bears prefer cooler temperatures, particularly in winter for hybernation. They prefer to live in a place with rain so that the soil is moist and supports dense vegetation, and there are water sources.\n\n\nCode\nimport pandas as pd \n\ndata = pd.read_csv(\"../../../data/NABR_historic.csv\")\n\ndata_colmap = {\n    \"long\" : \"longitude\",\n    \"lat\" : \"latitude\",\n    \"TimePeriod\" : \"time_period\",\n    \"RCP\" : \"rep_con_path\",\n    \"treecanopy\" : \"pct_treecanopy\", \n    \"Ann_Herb\" : \"pct_annual_herbcov\",\n    \"Bare\" : \"pct_bareground\",\n    \"Herb\" : \"pct_herbcov\",\n    \"Litter\" : \"pct_plantlittercov\",\n    \"Shrub\" : \"pct_shrubcov\",\n    \"DrySoilDays_Summer_whole\" : \"drysoildays_summer\",\n    \"Evap_Summer\" : \"evap_summer\", \n    \"ExtremeShortTermDryStress_Summer_whole\" : \"xtr_st_drysoilstress_summer\", \n    \"FrostDays_Winter\" : \"frostdays_winter\", \n    \"NonDrySWA_Summer_whole\" : \"nondry_swa_summer\",\n    \"PPT_Winter\" : \"precipitation_winter\", \n    \"PPT_Summer\" : \"precipitation_summer\",\n    \"PPT_Annual\" : \"precipitation_annual\", \n    \"T_Winter\" : \"temp_winter\",\n    \"T_Summer\" : \"temp_summer\", \n    \"T_Annual\" : \"temp_annual\", \n    \"Tmax_Summer\" : \"maxtemp_summer\", \n    \"Tmin_Winter\" : \"mintemp_winter\", \n    \"VWC_Winter_whole\" : \"volwater_winter\", \n    \"VWC_Spring_whole\" : \"volwater_spring\", \n    \"VWC_Summer_whole\" : \"volwater_summer\", \n    \"VWC_Fall_whole\" : \"volwater_fall\"\n}\n\ndata = data.rename(columns=data_colmap)\n\nsoil_data_cols = ['year', 'pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer'] \n\nsoil_data = data[soil_data_cols]\n\nsoil_data_agg = soil_data.groupby(\"year\")[['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer']].agg(\"mean\").reset_index()\n\ndata_agg = data.groupby(\"year\")[['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer',\n       'frostdays_winter', 'nondry_swa_summer', 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter',\n       'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall']].agg('mean').reset_index()\n\n\n\nimport plotly.express as px\n\npx.scatter(soil_data_agg, x = \"year\", y = ['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer'], trendline = \"ols\")\n\n/Users/reneedemaio/Library/Python/3.9/lib/python/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning:\n\nurllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport plotly.express as px\nimport pandas as pd\n\napp = dash.Dash(__name__)\n\ncolumns = ['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer']\n\napp.layout = html.Div([\n    html.H1(\"Interactive Soil and Coverage Data Graph\"),\n    \n    html.Div([\n        html.Label(\"Select Y-axis:\"),\n        dcc.Dropdown(\n            id='y-axis-dropdown',\n            options=[{'label': col, 'value': col} for col in columns],\n            value='pct_treecanopy', \n            multi = True\n        ),\n    ]),\n    \n    dcc.Graph(id='scatter-plot')\n])\n\n@app.callback(\n    Output('scatter-plot', 'figure'),\n     Input('y-axis-dropdown', 'value')\n)\ndef update_graph(y_axis):\n    fig = px.scatter(data_agg, x=\"maxtemp_summer\", y=y_axis, title=f'{y_axis} vs Year', trendline = \"ols\")\n    return fig\n\nif __name__ == '__main__':\n    app.run_server(debug=True, port = 8052)\n\n\n        \n        \n\n\n\ntemp_data = pd.read_csv(\"../../../data/cleaned_temp_subset.csv\")\n\ntemp_data = temp_data.drop(columns=\"Unnamed: 0\")\n\ntemp_soil_data = pd.merge(temp_data, soil_data_agg, on = \"year\", how = \"outer\")\n\n\nimport dash\nfrom dash import dcc, html\nfrom dash.dependencies import Input, Output\nimport plotly.express as px\nimport pandas as pd\n\napp = dash.Dash(__name__)\n\ncolumns = ['pct_treecanopy', 'pct_annual_herbcov', 'pct_bareground',\n       'pct_herbcov', 'pct_plantlittercov', 'pct_shrubcov',\n       'drysoildays_summer', 'evap_summer', 'xtr_st_drysoilstress_summer',\n       'frostdays_winter', 'nondry_swa_summer', 'precipitation_winter',\n       'precipitation_summer', 'precipitation_annual', 'temp_winter',\n       'temp_summer', 'temp_annual', 'maxtemp_summer', 'mintemp_winter',\n       'volwater_winter', 'volwater_spring', 'volwater_summer',\n       'volwater_fall']\n\napp.layout = html.Div([\n    html.H1(\"Interactive Temperature and Soil Data Graph\"),\n    \n    html.Div([\n        html.Label(\"Select Y-axis:\"),\n        dcc.Dropdown(\n            id='y-axis-dropdown',\n            options=[{'label': col, 'value': col} for col in columns],\n            value='pct_treecanopy', \n            multi = True\n        ),\n    ]),\n    \n    dcc.Graph(id='scatter-plot')\n])\n\n@app.callback(\n    Output('scatter-plot', 'figure'),\n     Input('y-axis-dropdown', 'value')\n)\ndef update_graph(y_axis):\n    fig = px.line(temp_soil_data, x=\"year\", y=y_axis, title=f'{y_axis} vs Year')\n    return fig\n\nif __name__ == '__main__':\n    app.run_server(debug=True, port = 8053)"
  }
]